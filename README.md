<p align="center">
  <img src="./docs/images/logo.png?v=1" width="420" alt="cache logo">
</p>

<p align="center">
    cache gives your services one cache API with memory and redis drivers.
</p>

<p align="center">
    <a href="https://pkg.go.dev/github.com/goforj/cache"><img src="https://pkg.go.dev/badge/github.com/goforj/cache.svg" alt="Go Reference"></a>
    <a href="LICENSE"><img src="https://img.shields.io/badge/license-MIT-blue.svg" alt="License: MIT"></a>
    <a href="https://golang.org"><img src="https://img.shields.io/badge/go-1.24+-blue?logo=go" alt="Go version"></a>
    <img src="https://img.shields.io/github/v/tag/goforj/cache?label=version&sort=semver" alt="Latest tag">
    <a href="https://goreportcard.com/report/github.com/goforj/cache"><img src="https://goreportcard.com/badge/github.com/goforj/cache" alt="Go Report Card"></a>
<!-- test-count:embed:start -->
    <img src="https://img.shields.io/badge/tests-35-brightgreen" alt="Tests">
<!-- test-count:embed:end -->
</p>

<p align="center">
  <img src="https://img.shields.io/badge/drivers-memory%20%E2%9C%85%20|%20redis%20%E2%9C%85-brightgreen" alt="Drivers">
  <img src="https://img.shields.io/badge/options-ttl%20|%20prefix%20|%20counters%20|%20add%20|%20memo-brightgreen" alt="Options">
</p>

## What cache is

An explicit cache abstraction with a minimal `Store` interface and ergonomic `Cache` helpers. Drivers are chosen when you construct the store (no env coupling), so swapping backends is a dependency-injection change instead of a refactor.

## Drivers

| Driver | Mode | Shared | Durable | TTL | Counters |
| ---: | :--- | :---: | :---: | :---: | :---: |
| <img src="https://img.shields.io/badge/memory-5c5c5c?logo=cachet&logoColor=white" alt="Memory"> | In-process | - | - | ✓ | ✓ |
| <img src="https://img.shields.io/badge/redis-%23DC382D?logo=redis&logoColor=white" alt="Redis"> | Networked | ✓ | - | ✓ | ✓ |

## Installation

```bash
go get github.com/goforj/cache
```

## Quick Start

```go
import (
    "context"
    "time"

    "github.com/goforj/cache"
    "github.com/redis/go-redis/v9"
)

func main() {
    ctx := context.Background()

    store := cache.NewStoreWith(ctx, cache.DriverMemory,
        cache.WithDefaultTTL(5*time.Minute),
        cache.WithMemoryCleanupInterval(10*time.Minute),
    )
    repo := cache.NewCache(store)

    // Remember pattern.
    profile, err := repo.Remember(ctx, "user:42:profile", time.Minute, func(context.Context) ([]byte, error) {
        return []byte(`{"name":"ada"}`), nil
    })
    _ = profile

    // Switch to Redis (dependency injection, no code changes below).
    client := redis.NewClient(&redis.Options{Addr: "127.0.0.1:6379"})
    store = cache.NewStoreWith(ctx, cache.DriverRedis,
        cache.WithRedisClient(client),
        cache.WithPrefix("app"),
        cache.WithDefaultTTL(5*time.Minute),
    )
    repo = cache.NewCache(store)
}
```

## StoreConfig

`StoreConfig` keeps configuration explicit:

- `Driver`: `DriverMemory` (default) or `DriverRedis`
- `DefaultTTL`: fallback TTL when a call provides `ttl <= 0`
- `MemoryCleanupInterval`: sweep interval for memory driver
- `Prefix`: key prefix for shared backends
- `RedisClient`: required when using the Redis driver

## Cache helpers

`Cache` wraps a `Store` with ergonomic helpers:

- `Remember`, `RememberString`, `RememberJSON`
- `Get`, `GetString`, `GetJSON`
- `Set`, `SetString`, `SetJSON`
- `Add`, `Increment`, `Decrement`
- `Pull`, `Delete`, `DeleteMany`, `Flush`

Example:

```go
settings, err := cache.RememberJSON[Settings](ctx, repo, "settings:alerts", 10*time.Minute, func(context.Context) (Settings, error) {
    return fetchSettings(ctx)
})
```

## Memoized reads

Wrap any store with `NewMemoStore` to memoize reads within the process; cache is invalidated automatically on write paths.

```go
memoStore := cache.NewMemoStore(store)
memoRepo := cache.NewCache(memoStore)
```

**Staleness note:** memoization is per-process only. Writes that happen in *other* processes (or outside your app) will not invalidate this memo cache. Use it when local staleness is acceptable, or scope it narrowly (e.g., per-request) if multiple writers exist.

## Testing

Unit tests cover the public helpers. Integration tests use `testcontainers-go` to spin up Redis:

```bash
go test -tags=integration ./...
```

Use `INTEGRATION_DRIVER=redis` (comma-separated; defaults to `all`) to select which drivers start containers and run the contract suite.

## API reference

The API section below is autogenerated; do not edit between the markers.

<!-- api:embed:start -->

## API Index

| Group | Functions |
|------:|:-----------|
| **Constructors** | [NewCache](#newcache) [NewCacheWithTTL](#newcachewithttl) [NewStore](#newstore) |
| **Memoization** | [NewMemoStore](#newmemostore) |
| **Cache** | [Add](#add) [Decrement](#decrement) [Delete](#delete) [DeleteMany](#deletemany) [Flush](#flush) [Get](#get) [GetString](#getstring) [Increment](#increment) [Pull](#pull) [Remember](#remember) [RememberString](#rememberstring) [Set](#set) [SetString](#setstring) [Store](#store) |
| **Cache JSON** | [GetJSON](#getjson) [RememberJSON](#rememberjson) [SetJSON](#setjson) |


## Constructors

### <a id="newcache"></a>NewCache

NewCache creates a cache facade bound to a concrete store.

```go
ctx := context.Background()
store := cache.NewMemoryStore(ctx)
repo := cache.NewCache(store)
_ = repo
```

### <a id="newcachewithttl"></a>NewCacheWithTTL

NewCacheWithTTL lets callers override the default TTL applied when ttl <= 0.

```go
ctx := context.Background()
store := cache.NewMemoryStore(ctx)
repo := cache.NewCacheWithTTL(store, 2*time.Minute)
_ = ctx
_ = repo
```

### <a id="newstore"></a>NewStore

NewStore returns a concrete store for the requested driver.
Caller is responsible for providing any driver-specific dependencies.

```go
ctx := context.Background()
store := cache.NewMemoryStore(ctx)
_ = store
```

## Memoization

### <a id="newmemostore"></a>NewMemoStore

NewMemoStore decorates store with per-process read memoization.

Behavior:
- First Get hits the backing store, clones the value, and memoizes it in-process.
- Subsequent Get for the same key returns the memoized clone (no backend call).
- Any write/delete/flush invalidates the memo entry so local reads stay in sync
with changes made through this process.
- Memo data is per-process only; other processes or external writers will not
invalidate it. Use only when that staleness window is acceptable.

```go
ctx := context.Background()
base := cache.NewMemoryStore(ctx)
memoStore := cache.NewMemoStore(base)
repo := cache.NewCache(memoStore)
_ = repo
```

## Cache

### <a id="add"></a>Add

Add writes value only when key is not already present.

```go
ctx := context.Background()
store := cache.NewMemoryStore(ctx)
repo := cache.NewCache(store)
created, _ := repo.Add(ctx, "boot:seeded", []byte("1"), time.Hour)
_ = created
```

### <a id="decrement"></a>Decrement

Decrement decrements a numeric value and returns the result.

```go
ctx := context.Background()
store := cache.NewMemoryStore(ctx)
repo := cache.NewCache(store)
value, _ := repo.Decrement(ctx, "rate:login:42", 1, time.Minute)
_ = value
```

### <a id="delete"></a>Delete

Delete removes a single key.

```go
ctx := context.Background()
store := cache.NewMemoryStore(ctx)
repo := cache.NewCache(store)
_ = repo.Delete(ctx, "a")
```

### <a id="deletemany"></a>DeleteMany

DeleteMany removes multiple keys.

```go
ctx := context.Background()
store := cache.NewMemoryStore(ctx)
repo := cache.NewCache(store)
_ = repo.DeleteMany(ctx, "a", "b")
```

### <a id="flush"></a>Flush

Flush clears all keys for this store scope.

```go
ctx := context.Background()
store := cache.NewMemoryStore(ctx)
repo := cache.NewCache(store)
_ = repo.Flush(ctx)
```

### <a id="get"></a>Get

Get returns raw bytes for key when present.

```go
ctx := context.Background()
repo := cache.NewCache(cache.NewMemoryStore(ctx))
_ = repo.Set(ctx, "user:42", []byte("Ada"), 0)
value, ok, _ := repo.Get(ctx, "user:42")
_ = value
_ = ok
```

### <a id="getstring"></a>GetString

GetString returns a UTF-8 string value for key when present.

```go
ctx := context.Background()
repo := cache.NewCache(cache.NewMemoryStore(ctx))
_ = repo.SetString(ctx, "user:42:name", "Ada", 0)
name, ok, _ := repo.GetString(ctx, "user:42:name")
_ = name
_ = ok
```

### <a id="increment"></a>Increment

Increment increments a numeric value and returns the result.

```go
ctx := context.Background()
repo := cache.NewCache(cache.NewMemoryStore(ctx))
value, _ := repo.Increment(ctx, "rate:login:42", 1, time.Minute)
_ = value
```

### <a id="pull"></a>Pull

Pull returns value and removes it from cache.

```go
ctx := context.Background()
repo := cache.NewCache(cache.NewMemoryStore(ctx))
_ = repo.SetString(ctx, "reset:token:42", "abc", time.Minute)
body, ok, _ := repo.Pull(ctx, "reset:token:42")
_ = body
_ = ok
```

### <a id="remember"></a>Remember

Remember returns key value or computes/stores it when missing.

```go
ctx := context.Background()
repo := cache.NewCache(cache.NewMemoryStore(ctx))
data, err := repo.Remember(ctx, "dashboard:summary", time.Minute, func(context.Context) ([]byte, error) {
	return []byte("payload"), nil
})
_ = data
_ = err
```

### <a id="rememberstring"></a>RememberString

RememberString returns key value or computes/stores it when missing.

```go
ctx := context.Background()
repo := cache.NewCache(cache.NewMemoryStore(ctx))
value, err := repo.RememberString(ctx, "settings:mode", time.Minute, func(context.Context) (string, error) {
	return "on", nil
})
_ = value
_ = err
```

### <a id="set"></a>Set

Set writes raw bytes to key.

```go
ctx := context.Background()
repo := cache.NewCache(cache.NewMemoryStore(ctx))
_ = repo.Set(ctx, "token", []byte("abc"), time.Minute)
```

### <a id="setstring"></a>SetString

SetString writes a string value to key.

```go
ctx := context.Background()
repo := cache.NewCache(cache.NewMemoryStore(ctx))
_ = repo.SetString(ctx, "user:42:name", "Ada", time.Minute)
```

### <a id="store"></a>Store

Store returns the underlying store implementation.

## Cache JSON

### <a id="getjson"></a>GetJSON

GetJSON decodes a JSON value into T when key exists.

```go
type Profile struct { Name string `json:"name"` }
ctx := context.Background()
repo := cache.NewCache(cache.NewMemoryStore(ctx))
_ = cache.SetJSON(ctx, repo, "profile:42", Profile{Name: "Ada"}, 0)
profile, ok, _ := cache.GetJSON[Profile](ctx, repo, "profile:42")
_ = profile
_ = ok
```

### <a id="rememberjson"></a>RememberJSON

RememberJSON returns key value or computes/stores JSON when missing.

```go
type Settings struct { Enabled bool `json:"enabled"` }
ctx := context.Background()
repo := cache.NewCache(cache.NewMemoryStore(ctx))
settings, err := cache.RememberJSON[Settings](ctx, repo, "settings:alerts", time.Minute, func(context.Context) (Settings, error) {
	return Settings{Enabled: true}, nil
})
_ = settings
_ = err
```

### <a id="setjson"></a>SetJSON

SetJSON encodes value as JSON and writes it to key.

```go
type Profile struct { Name string `json:"name"` }
ctx := context.Background()
repo := cache.NewCache(cache.NewMemoryStore(ctx))
_ = cache.SetJSON(ctx, repo, "profile:42", Profile{Name: "Ada"}, time.Minute)
```
<!-- api:embed:end -->
